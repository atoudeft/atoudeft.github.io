<p>
  Une interface est comme une classe abstraite qui ne contient que des méthodes
  abstraites et des constantes (les attributs d’une interface sont
  automatiquement constants).
</p>
<h2 id="sec-definition-dune-interface">
  <a id="_Toc97498607"></a>Définition d’une interface
</h2>
<p>
  Une interface est définie à l’aide du mot-clé
  <strong><em>interface</em></strong> au lieu de <strong><em>class</em></strong
  >&nbsp;:
</p>
<p class="code java">
  <span class="langage">Java</span>
public <span class="en-evidence">interface</span> MonInterface {<br>
&nbsp;&nbsp;void methode1(int x, double y);<br>
&nbsp;&nbsp;double methode2(String s);<br>
}
</p>
<p>
  Une interface permet de définir (ou plutôt d’imposer) la liste des méthodes
  que des classes doivent fournir pour interagir avec.
</p>
<p>
  Par exemple, il existe différents types de messages&nbsp;: message texte,
  message audio, vidéo, … On peut imposer que tous les types de messages
  fournissent une méthode <strong><em>lire()</em></strong> pour lire le
  message&nbsp;:
</p>
<p class="code java">
  <span class="langage">Java</span>
public interface Message {<br>
&nbsp;&nbsp;void lire();<br>
}
</p>
<p>
  Autre exemple, on peut définir une interface
  <strong><em>Pile</em></strong> pour imposer les méthodes qu’une pile doit
  fournir, indépendamment de la façon dont elle est implémentée&nbsp;:
</p>
<p class="code java">
  <span class="langage">Java</span>
public interface Pile {<br>
&nbsp;&nbsp;boolean empiler(Object x);<br>
&nbsp;&nbsp;Object depiler() throws Exception;<br>
&nbsp;&nbsp;boolean estVide();<br>
&nbsp;&nbsp;Object peek() throws Exception;<br>
&nbsp;&nbsp;int taille();<br>
&nbsp;&nbsp;void vider();<br>
}<br>
</p>
<p>On peut faire la même chose pour les files (queues) et les listes.</p>
<h2 id="sec-implementation-dune-interface">
  <a id="_Toc97498608"></a>Implémentation d’une interface
</h2>
<p>
  Une classe peut <strong>implémenter une interface</strong>. Elle est alors
  <strong>obligée</strong> de définir toutes les méthodes de l’interface (sinon
  la classe doit être abstraite)&nbsp;:
</p>
<p class="code java">
  <span class="langage">Java</span>
public class MaClasse <span class="en-evidence">implements</span> MonInterface {<br>
&nbsp;&nbsp;//attributs et méthodes...<br>
&nbsp;&nbsp;//Définition des 2 méthodes de l’interface&nbsp;:<br>
&nbsp;&nbsp;void methode1(int x, double y) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;//...</p>
&nbsp;&nbsp;}</p>
&nbsp;&nbsp;double methode2(String s) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;//...<br>
&nbsp;&nbsp;}<br>
}
</p>
<p>
  Par exemple, l’interface <strong><em>Message</em></strong> va être implémentée
  par toutes les classes de messages&nbsp;:
</p>
<p class="code java">
  <span class="langage">Java</span>
public class MessageTexte <span class="en-evidence">implements</span> Message {<br>
&nbsp;&nbsp;//attributs et méthodes...<br>
&nbsp;&nbsp;//Définition de la méthode de l’interface&nbsp;:<br>
&nbsp;&nbsp;void lire() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;//lire le message texte<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
public class MessageAudio <span Message {<br>
&nbsp;&nbsp;//attributs et méthodes...<br>
&nbsp;&nbsp;//Définition de la méthode de l’interface&nbsp;:<br>
&nbsp;&nbsp;void lire() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;//lire le message audio<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
public class MessageVideo <span class="en-evidence">implements</span> Message {<br>
&nbsp;&nbsp;//attributs et méthodes...<br>
&nbsp;&nbsp;//Définition de la méthode de l’interface&nbsp;:<br>
&nbsp;&nbsp;void lire() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;//lire le message vidéo<br>
&nbsp;&nbsp;}<br>
}
</p>
<p>
  De même, les classes <strong><em>PileStatique</em></strong
  >, <strong><em>PileChaineeSimple</em></strong> et
  <strong><em>PileChaineeDouble</em></strong> vont implémenter l’interface
  <strong><em>Pile</em></strong> et fournir les mêmes méthodes imposées par
  l’interface mais implémentées différemment dans chacune des classes&nbsp;:
</p>
<p class="code java">
  <span class="langage">Java</span>
public class PileStatique <span class="en-evidence">implements</span> Pile {<br>
&nbsp;&nbsp;//...implémentation statique avec tableau<br>
}<br>
public class PileChaineeSimple <span class="en-evidence">implements</span> Pile {<br>
&nbsp;&nbsp;//...implémentation avec chainage simple<br>
}<br>
<br>
public class PileChaineeDouble <span class="en-evidence">implements</span> Pile {<br>
&nbsp;&nbsp;//...implémentation avec chainage double<br>
}
</p>
<p>
  En <em>Java</em>, une classe ne peut dériver que d’une classe mère (héritage
  simple) mais <strong>peut implémenter plusieurs interfaces</strong>&nbsp;:
</p>
<p>
  public class MaClasse2 extends MaClasse1 implements MonInterface1,
  MonInterface2, MonInterface3 {
</p>
<p>//attributs et méthodes...</p>
<p>//Définition de toutes les méthodes de toutes les interfaces</p>
<p>//...</p>
<p>}</p>
<h2 id="sec-proprietes-des-interfaces">
  <a id="_Toc97498609"></a>Propriétés des interfaces
</h2>
<ul>
  <li>On peut faire de l’héritage (même multiple) d’interfaces&nbsp;:</li>
</ul>
<p class="code java">
  <span class="langage">Java</span>
public interface MonInterface1 {<br>
&nbsp;&nbsp;void f();<br>
}<br>
public interface MonInterface2 {<br>
&nbsp;&nbsp;void g();<br>
}<br>
public interface MonInterface3 <span class="en-evidence">extends</span> MonInterface1 {<br>
&nbsp;&nbsp;void h();<br>
}
</p>
<p>
  <strong><em>MonInterface3</em></strong> contient les méthodes
  <strong><em>h()</em></strong> et <strong><em>f()</em></strong> (héritée de
  <strong><em>MonInterface1</em></strong
  >).
</p>
<p class="code java">
  <span class="langage">Java</span>
public interface MonInterface4 extends MonInterface1, MonInterface2 {<br>
&nbsp;&nbsp;void r();<br>
}
</p>
<p>
  <strong><em>MonInterface4</em></strong> contient les méthodes
  <strong><em>r()</em></strong
  >, <strong><em>f()</em></strong> (héritée de
  <strong><em>MonInterface1</em></strong
  >) et <strong><em>g()</em></strong> (héritée de
  <strong><em>MonInterface2</em></strong
  >).
</p>
<ul>
  <li>On peut déclarer des variables de type interface&nbsp;:</li>
</ul>
<p class="code java">
  <span class="langage">Java</span>
Message message;<br>
Pile pile;
</p>
<p>Mais, on ne peut pas instancier une interface&nbsp;:</p>
<p class="code java">
  <span class="langage">Java</span>
message = new Message(); //NON<br>
pile = new Pile(); //NON
</p>
<p>Ces variables doivent référencer des objets de classes concrètes&nbsp;:</p>
<p class="code java">
  <span class="langage">Java</span>
message = new MessageTexte(); //OK<br>
pile = new PileChaineeSimple(); //OK
</p>
<ul>
  <li>
    On peut tester si un objet est «&nbsp;instance&nbsp;» d’une interface. Cela
    veut dire que l’objet est instance d’une classe qui implémente
    l’interface&nbsp;:
  </li>
</ul>
<p class="code java">
  <span class="langage">Java</span>
PileChaineeDouble pile2 = new PileChaineeDouble();<br>
if (pile2 <span class="en-evidence">instanceof</span> Pile) { /*teste si la classe de pile2 implémente l’interface Pile.*/<br>
}
</p>
<h2 id="sec-programmation-par-contrats">
  <a id="_Toc97498610"></a>Programmation par contrats
</h2>
<p>
  Les interfaces sont au cœur de la <strong>programmation par contrats</strong>,
  utilisée en particulier dans le développement des API (bibliothèques orientées
  objet).
</p>
<p>
  La programmation par contrats permet aussi à différentes équipes de
  programmeurs de travailler sur un même projet de développement sans se
  connaitre et sans mélanger leurs codes. Les équipes s’entendent sur un même
  contrat qui se présente sous forme d’une série d’interfaces.
</p>
<p><strong>Exemple&nbsp;: </strong></p>
<p>
  On veut créer un menu de navigation dans différentes listes d’objets (pour
  naviguer dans une liste d’étudiants, dans une liste de produits, dans une
  liste de compte bancaires, …).
</p>
<p>Le menu de navigation permettra les opérations suivantes&nbsp;:</p>
<ul>
  <li>Se déplacer au <strong>premier</strong> élément;</li>
  <li>Se déplacer au <strong>dernier</strong> élément;</li>
  <li>
    Obtenir l’élément <strong>courant</strong> (là où on est rendu dans la
    navigation);
  </li>
  <li>Se déplacer au <strong>suivant</strong> (de l’élément courant);</li>
  <li>Se déplacer au <strong>précédent</strong> (de l’élément courant);</li>
</ul>
<p>
  Le menu de navigation a-t-il besoin de connaitre dans quel type de liste on
  navigue (des étudiants, des produits, …) ?
</p>
<p>
  Grâce aux interfaces, la <strong>réponse est non</strong>. On va définir un
  contrat qui impose les méthodes que les listes doivent fournir pour qu’on
  puisse naviguer dedans. On définit donc une interface qu’on va appeler, par
  exemple, <strong><em>Navigable</em></strong
  >&nbsp;:
</p>
<p class="code java">
  <span class="langage">Java</span>
public interface Navigable {<br>
&nbsp;&nbsp;public boolean allerAuPremier();<br>
&nbsp;&nbsp;public boole4an allerAuDernier();<br>
&nbsp;&nbsp;public boolean allerAuSuivant();<br>
&nbsp;&nbsp;public boolean allerAuPrecedent();<br>
&nbsp;&nbsp;public Object getCourant();<br>
}
</p>
<p>
  À partir de là, on peut programmer notre menu de navigation qui va travailler
  sur un objet de type <strong><em>Navigable</em></strong
  >.
</p>
<p>
  En mode console, le code de navigation ressemblerait à ceci (on peut aussi
  envisager une implémentation similaire en mode graphique)&nbsp;:
</p>
<p class="code java">
  <span class="langage">Java</span>
Navigable navigable = ???;<br>
Object courant;<br>
char choix = clavier.nextLine().charAt(0);<br>

while (choix != <strong><em>QUITTER</em></strong>) {<br>
&nbsp;&nbsp;switch (choix) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;case 'p': //premier<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigable.allerAuPremier();<br>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;case 'd': //dernier<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigable.allerAuDernier();<br>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;case 's': //suivant<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigable.allerAuSuivant();<br>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;case 'r': //précédent<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigable.allerAuPrecedent();<br>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;case 'c': //obtenir le courant et l’afficher<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;courant = navigable.getCourant();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (courant!=null)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.<em>out</em>.println(courant);<br>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;choix = clavier.nextLine().charAt(0);<br>
}
</p>
<p>
  Le code de navigation est complet. Tout ce qui manque, c’est l’objet référencé
  par la variable <strong><em>navigable</em></strong
  >.
</p>
<p>
  Le programmeur qui crée la liste d’étudiants peut bénéficier de ce code de
  navigation pour naviguer à travers les étudiants à condition qu’il respecte le
  contrat&nbsp;: sa classe <strong><em>ListeEtudiants</em></strong> doit
  implémenter l’interface <strong><em>Navigable</em></strong
  >.
</p>
<p>Voici, par exemple, à quoi peut ressembler la classe&nbsp;:</p>
<p class="code java">
  <span class="langage">Java</span>
public class ListeEtudiants implements Navigable {<br>
&nbsp;&nbsp;private Etudiant[] lesEtudiants = new Etudiant[50];<br>
&nbsp;&nbsp;private int nbEtudiants;<br>
&nbsp;&nbsp;private int indiceCourant = -1; <br>
&nbsp;&nbsp;public boolean ajouter(Etudiant e) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (this.nbEtudiants==this.lesEtudiants.length)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this.lesEtudiants[nbEtudiants] = e;<br>
&nbsp;&nbsp;&nbsp;&nbsp;nbEtudiants++;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;public boolean allerAuPremier() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (nbEtudiants==0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indiceCourant = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;public boolean allerAuDernier() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (nbEtudiants==0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indiceCourant = nbEtudiants-1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;public boolean allerAuSuivant() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (indiceCourant == nbEtudiants-1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indiceCourant++;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;public boolean allerAuPrecedent() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (indiceCourant &lt;= 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indiceCourant--;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;public Object getCourant() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (nbEtudiants==0 || indiceCourant &lt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br>
&nbsp;&nbsp;&nbsp;&nbsp;else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.lesEtudiants[indiceCourant];<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
}
</p>
<p>
  Une liste de produits ou de comptes bancaires peut être implémentée de manière
  similaire (avec tableaux ou <strong><em>ArrayList</em></strong> ou autre).
</p>
<p>
  Il suffit de référencer la liste avec la variable
  <strong><em>navigable</em></strong> pour naviguer dedans&nbsp;:
</p>
<p class="code java">
  <span class="langage">Java</span>
ListeEtudiants etuds = new ListeEtudiants();<br>
ListeProduits prods = new ListeProduits();<br>
navigable = etuds;<br>
//ou&nbsp;:<br>
navigable = prods;
</p>
